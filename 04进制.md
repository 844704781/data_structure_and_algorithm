## 数制

### 概念

**数制**，也称为计数值。是一组由数字符号和统一的规则来表示数值的方法。任何一个数制都包含两个基本要素：基数和权。

数制的固定符号: 数字符号(0-9)，字母(A-F)等。

数制的统一规则:

1. **十进制（Decimal）：** 在十进制中，每个位置的权值都是 10 的幂次方。例如，数值 4567 表示为 4 * 10^3 + 5 * 10^2 + 6 * 10^1 + 7 * 10^0。
2. **二进制（Binary）：** 在二进制中，每个位置的权值都是 2 的幂次方。例如，数值 1011 表示为 1 * 2^3 + 0 * 2^2 + 1 * 2^1 + 1 * 2^0。
3. **八进制（Octal）：** 在八进制中，每个位置的权值都是 8 的幂次方。例如，数值 123 表示为 1 * 8^2 + 2 * 8^1 + 3 * 8^0。
4. **十六进制（Hexadecimal）：** 在十六进制中，除了数字 0-9 外，还使用字母 A-F 来表示 10-15。每个位置的权值都是 16 的幂次方。例如，数值 1A3 表示为 1 * 16^2 + 10 * 16^1 + 3 * 16^0。

**基数**:

就是逢几进位，二进制逢二进位，所以二进制的基数是2，十进制逢十进位，所以十进制的基数是10。

**权**:

数制中某个数值位置的价值。

比如十进制的123,1所在位置是百位，权是100,2所在位置是十位，权是10，3所在位置是个位，所在权是1。

比如二进制的1011，第一个1的权是8，第一个0的权是4，第二个1的权是2，第三个3的权是1。



### 常用的数制

#### 十进制



##### 计数符号

0,1,2,3,4,5,6,7,8,9



##### 进位规则

逢十进一



##### 采用的位置计数法

![](./img/015.png)

上面的累加表达式含义:

由于整数位个数为4，小数位个数为2，所以上述表达式对 i 的范围是从 -2 到 3。

在这个表达式中，`d(i)` 代表当指数为 i 时，系数的值。例如，当 i 为 -2 时，系数的值为 5。因此，这个表达式展开后就是上面所描述的表示法。



十进制中的权值分配：

在十进制中，数值的每一位的权值是基数 10 的整数次幂。对于整数部分，权值为 10 的正次幂，而对于小数部分，权值为 10 的负次幂。

权值从右向左递增。

因此，任何一个十进制数 d 可以表示为加权系数之和，其中 n 为整数位个数，m 为小数位个数，$d(i)$ 为第 i 位的基数符号，也称之为系数。



#### 二进制



##### 计数符号

0,1



##### 进位规则

逢二进一



##### 采用的位置计数法

![](./img/016.png)

在二进制数中，不同位置的 1 代表的值是不同的。从左到右的每个 1 所代表的十进制值如下：

- 第 1 个 1 代表的是 2^2
- 第 2 个 1 代表的是 2^0
- 第 3 个 1 代表的是 2^-1
- 第 4 个 1 代表的是 2^-2

在二进制中，我们为每一个计数符号位分配一个权值。权值为 2 的整数次幂，整数的权值为 2 的正次幂，负数的权值为 2 的负次幂。从 0 开始，0 的左边，从右往左递增。

因此，任何一个二进制数 b 可以表示为加权系数之和，其中 n 为整数位个数，m 为小数位个数，b(i) 为第 i 位的计数符号，也称之为系数。



##### 注意

二进制在计算机中通常会加0b前缀，比如0b10,代表十进制2



#### 十六进制



##### 计数符号

0,1,2...7,8,9,A,B,C,D,E,F



##### 进位规则

逢十六进一



##### 采用的位置计数法

![](./img/017.png)





##### 注意

在计算机中，十六进制通常会在前面加0x,比如0x1，代表十进制1,0xf代表十进制15，

0x10代表十进制16



#### 八进制

##### 计数符号

0,1,2,3,4,5,6,7



##### 进位规则

逢八进一



##### 采用的位置计数法

![](./img/018.png)

##### 注意

计算机中，8进制数通常会在前面加0，比如010其实代表十进制的8



* 八进制对比十进制

​	八进制数:0,1,2,3,4,5,6,7,10,11,12,13,14,15,16,17,20

​	十进制数:...8 9 10 11 12 13 14 15 16

## 进制转换

### 二进制转十进制

不管整数还是小数，都可以用这个方法

按权展开法

![](./img/019.png)





### 十进制转二进制

> 短除法，连乘法

#### 整数部分短除法

![](./img/020.png)

#### 小数部分连乘法

![](./img/021.png)

十进制转二进制的小数部分采用练乘法

即将小数部分一直乘以2，直到等于0或者达到规定的位数，然后把每次所得的整数按序排列就可以得到等值的二进制数

**注意:**

在进行二进制和十进制之间的转换时，我们常常需要保持精度不变。当某个十进制小数连续乘以2，最终导致小数部分等于0时，就需要采用等精度的有效位数表示法。根据该方法，可以推导出一个公式：对于一个 m 位的十进制小数，需要选择 3m+1 位二进制小数来保持等精度。

举例来说，考虑十进制数 0.37，其对应的二进制数0.010111101011100001010001111010111000010100011110101111…原本包含了很多位数。然而，根据等精度的有效位数表示法，二进制的小数部分有两位，所以m为2，我们只需取 3*2+1 = 7 位二进制数来表示。因此，0.37 对应的二进制数可以简化为 0.0101111。



### 二进制转十六进制

> 四个为一组直接转

1. 将二进制数从右向左以每 4 位一组进行分组。
2. 每组二进制数对应一个十六进制数的位。
3. 将每组二进制数转换为对应的十六进制数。

例如，考虑二进制数 `1101101011101011`：

1. 将二进制数分组为 `1101` `1010` `1110` `1011`。
2. 将每组二进制数分别转换为对应的十六进制数。
3. 得到十六进制数 `D` `A` `E` `B`。

因此，二进制数 `1101101011101011` 对应的十六进制数为 `DAEB`。



### 十六进制转二进制

> 每位十六进制直接转

将十六进制数转换为二进制数通常是通过将每个十六进制数字转换为对应的四位二进制数来实现的。具体步骤如下：

1. 将十六进制数中的每个十六进制数字转换为对应的四位二进制数。
2. 将得到的每组四位二进制数连接起来，得到最终的二进制数。

例如，考虑十六进制数 `3A7F`：

1. 将十六进制数字 `3` 转换为二进制数 `0011`，`A` 转换为 `1010`，`7` 转换为 `0111`，`F` 转换为 `1111`。
2. 连接得到的二进制数为 `001110100111111`。

因此，十六进制数 `3A7F` 对应的二进制数为 `001110100111111`。



### 十进制转十六进制

> 短除法

将十进制数转换为十六进制数通常是通过连续地进行除法和取余操作来实现的。具体步骤如下：

1. 用十六进制数的基数 16 连续地除以要转换的十进制数，直到商为 0 为止。
2. 每次除法操作的余数即为要转换的十进制数的对应十六进制位。
3. 将得到的余数按照相反的顺序排列，即可得到转换后的十六进制数。

例如，考虑十进制数 231：

1. 231 除以 16 商为 14，余数为 7。
2. 继续将商 14 除以 16，商为 0，余数为 14。
3. 得到的余数按照相反的顺序排列，即得到十六进制数 `E7`。

因此，十进制数 231 对应的十六进制数为 `E7`。



### 十六进制转八进制

>先转二进制
>
>再三位为一组转八进制

要将十六进制数转换为八进制数，通常可以通过先将十六进制数转换为二进制数，然后再将二进制数转换为八进制数来实现。具体步骤如下：

1. 将每个十六进制数字转换为对应的四位二进制数。
2. 将得到的每组四位二进制数以每三位一组进行分组。
3. 每组三位二进制数对应一个八进制数的位。
4. 将每组三位二进制数转换为对应的八进制数。

举例来说，考虑十六进制数 `2F5`：

1. 将十六进制数字 `2` 转换为二进制数 `0010`，`F` 转换为 `1111`，`5` 转换为 `0101`。
2. 得到二进制数 `001011111101`。
3. 将二进制数分组为 `001` `011` `111` `101`。
4. 将每组三位二进制数分别转换为对应的八进制数，得到八进制数 `13575`。

因此，十六进制数 `2F5` 对应的八进制数为 `13575`。



### 八进制转十六进制

> 先转二进制
>
> 再四位为一组转成十六进制


要将八进制数转换为十六进制数，可以先将八进制数转换为二进制数，然后再将二进制数转换为十六进制数。具体步骤如下：

1. 将八进制数的每一位转换为对应的三位二进制数。
2. 将得到的二进制数分组为四位一组。
3. 每组四位二进制数转换为对应的十六进制数。

举例来说，考虑八进制数 `5732`：

1. 将八进制数的每一位转换为对应的三位二进制数：`5` 转换为 `101`，`7` 转换为 `111`，`3` 转换为 `011`，`2` 转换为 `010`。
2. 得到二进制数 `101111011010`。
3. 将二进制数分组为四位一组：`1011` `1101` `1010`。
4. 将每组四位二进制数转换为对应的十六进制数：`B` `D` `A`。

因此，八进制数 `5732` 对应的十六进制数为 `BDA`。



### 总结

如果是

小进制转大进制：

​	转成十进制，统一用按权展开法。

​	转成八，十六进制，统一先转二进制，然后分组直接转换

大进制转小进制:

​	十进制转其它进制，统一用短除法或者连乘法

​	十六进制转八进制，统一先转二进制，然后直接分组转换

​	十六进制转二进制，每位直接转换



## 数字编码方案(码制)

### 无符号编码

#### BCD码

##### 概念

用四位二进制码来表示一位十进制数字，最出名的方案有8421码



**有权码与无权码**

权的概念和数制概念中全的概念一致，代表二进制每个位置都有价值。

比如8421码1001，第一个1的权是8，第二个1的权是1，所以1001的十进制是9。

其中8421,5421,2421为有权码，有权码中，8421码是最常用的



所以有权码就是有每个位置都有价值的编码方案，无权码就是每个位置都没有价值的编码方案



##### BCD码方案

![](./img/024.png)



###### 有权码(8421,5421,2421)

**8421码**

就是将一个十进制数每位都分组表示。



*用8421BCD码表示十进制数(73.5)10*

![](./img/022.png)



*把8421BCD码01100111.01011000转换为十进制数*

![](./img/023.png)



**5421码**



**2421码**




###### 无权码(余3码)
**余3码**

余3码属于无权码，不能用单纯从展开的方法来求它所表示的十进制数，余3码的每种编码，是在对应的**8421码基础上加上十进制数3，或者二进制0011**得到的。



##### 总结

​	8421 码是一种通用的数字编码方案，可以用于各种数字表示和控制的应用中。但在某些特定的情况下，选择其他码可能更经济，因为其他码可能更适合特定的硬件结构或应用场景，能够降低成本和复杂性。例如，对于数字显示设备驱动来说，5421 码可能更适合七段数码管的控制，而对于数字键盘输入数据处理来说，2421 码可能更简单有效。因此，在实际应用中，需要根据具体情况和需求选择合适的编码方案。




#### 格雷码

##### 概念

格雷码是一种无权码，可以弥补普通二进制加1时，改变的位数太多的问题，比如011的后面那位是010

![](./img/025.png)

例如，十进制数1变成2，格雷码从001，变成了011，只有G1位置发生了变化。而二进制数从001变成了010，有两位发生了变化。



##### 二进制转格雷码

![](./img/026.png)



![](./img/027.png)



##### 格雷码转二进制

![](./img/028.png)



#### ASCII码

##### 定义

ASCII码是7位二进制码，有128种组合，表示128个符号

​	除了数字以为，数字系统还需要处理字母，标点符号，控制命令等，我们把这种表示数字，字母和其他控制符号的编码叫做字母数字码。在字母数字码中，最常见的是ASCII码。

​	ASCII码是美国信息交换标准代码：ASCII码

​	ASCII码通常用在计算机和电子设备上，当你在计算机键盘上输入一个数字，字母或者控制命令时，键盘里的数字电路或者微处理器会产生响应的ASCII码送到计算机。



##### 部分ASCII码表

![](./img/029.png)



##### 扩展ASCII码

ASCII码也可以表示为8位，最高位为0，方便起见，可以用十六进制表示，范围从00到7F.

如果把8位的最高位用1表示，则又可以表示另外的128种符号，把这种编码叫做扩展ASCII码，用十六进制表示时，范围从80到FF，可以用来表示希腊字母，数学符号等。



#### 检错码和纠错码

##### 定义

在数字系统中经常要进行二进制信息的传输和存取，在信息的传输或者存取过程中，会由于受到某种干扰而发生错误，因此需要对接收到的信息或者读取的信息进行检查甚至纠错，从而出现了检错编码和纠错编码。



##### 奇偶校验码

奇偶校验码是具有检错能力的代码

它是在原码组的基础上增加一个比特，使码组中含1的个数为偶数或者奇数，如果为奇数则是奇校验，用1表示，如果为偶数则是偶校验，用0表示

###### 8421码加入奇偶校验码

![](./img/030.png)



​	以8421BCD码的0000，由于里面有0个1,0是偶数，则偶校验码为0，代表总的含1个数为偶数，第二个码组0001，由于含1的个数为1，1为非偶数，则偶校验码为1.最后一个码组1001，1的个数为2，为偶数，则偶校验码为0。在接收端，检测偶校验码码组中1的个数，如果1的个数为偶数，则偶校验码应该为0，如果发送过来的偶校验码也为0，则代表传输没有错误。



###### 注意

在一个给定的系统中，要么采用偶校验，要么采用奇校验，不能两者同时使用

注意，奇偶校验不能检验两位同时出错的情形，即不能检测偶数个比特发生错误的情形。比如本来应该发送 0 0000，如果右边第一个0出现了错误，变成了 0 0001，则接收端可以发现错误，但是如果右边第二位也发生了错误，变成了 0 0011，则接收端不能发现错误。因此，奇偶校验码仅适用于传输出错率很低，而且成对出现错误的概率几乎为0的情况。



### 有符号编码
**机器数**

一个数在计算机中的二进制表示形式，叫做这个数的机器数。

机器数是带符号的，在计算机用机器数的最高位存放符号，正数为0，负数为1。

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 100 00011 。

那么，这里的 0000 0011 和 1000 0011 就是机器数。



**真值**

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。

例如上面的有符号数 1000 0011，其最高位1代表负，其真正数值是 -3，而不是形式值131（1000 0011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1




#### 原码

原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如：如果是8位二进制：

[+1]原= 0000 0001

[-1]原= 1000 0001

第一位是符号位，因为第一位是符号位，所以8位二进制数的取值范围就是：（即第一位不表示值，只表示正负。）

[1111 1111 , 0111 1111]

即

[-127 , 127]

原码是人脑最容易理解和计算的表示方式。

#### 反码

反码的表示方法是：

正数的反码是其本身；

负数的反码是在其原码的基础上，符号位不变，其余各个位取反。

[+1] = [0000 0001]原= [0000 0001]反

[-1] = [1000 0001]原= [1111 1110]反

可见如果一个反码表示的是负数，人脑无法直观的看出来它的数值。通常要将其转换成原码再计算。

#### 补码

补码的表示方法是：

正数的补码就是其本身；

负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。(也即在反码的基础上+1)

也可以是原码的绝对值取反+1



[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补

[-1] = [1000 0001]原= [1111 1110]反= [1111 1111]补

对于负数，补码表示方式也是人脑无法直观看出其数值的。通常也需要转换成原码再计算其数值。

#### 为什么要使用原码反码补码

现在我们知道了计算机可以有三种编码方式表示一个数，对于正数因为三种编码方式的结果都相同：

[+1] = [0000 0001]原= [0000 0001]反= [0000 0001]补

所以不需要过多解释，但是对于负数：

[-1] = [10000001]原= [11111110]反= [11111111]补

可见原码，反码和补码是完全不同的。

既然原码才是被人脑直接识别并用于计算表示方式，为何还会有反码和补码呢？

首先, 因为人脑可以知道第一位是符号位，在计算的时候我们会根据符号位，选择对真值区域的加减。

但是对于计算机，加减乘数已经是最基础的运算，要设计的尽量简单，计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂！

于是人们想出了将符号位也参与运算的方法。我们知道，根据运算法则减去一个正数等于加上一个负数，即：1-1 = 1 + (-1) = 0， 所以机器可以只有加法而没有减法，这样计算机运算的设计就更简单了。

**于是人们开始探索将符号位参与运算，并且只保留加法的方法。**

首先来看原码：

计算十进制的表达式：1 - 1 = 0

1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [1000 0010]原= -2

如果用原码表示，让符号位也参与计算，显然对于减法来说，结果是不正确的。这也就是为何计算机内部不使用原码表示一个数。

**为了解决原码做减法的问题， 出现了反码：**

计算十进制的表达式：1 - 1 = 0

1 - 1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [0000 0001]反+ [1111 1110]反= [1111 1111]反= [1000 0000]原= -0

发现用反码计算减法，结果的真值部分是正确的。而唯一的问题其实就出现在"0"这个特殊的数值上，虽然人们理解上+0和-0是一样的，但是0带符号是没有任何意义的，而且会有[0000 0000]原和[1000 0000]原两个编码表示0。



**于是补码的出现，解决了0的符号问题以及0的两个编码问题：**

1-1 = 1 + (-1) = [0000 0001]原+ [1000 0001]原= [0000 0001]补+ [1111 1111]补= [1 0000 0000]补=[0000 0000]补=[0000 0000]原注意：进位1不在计算机字长里。

**这样0用[0000 0000]表示，而以前出现问题的-0则不存在了。而且可以用[1000 0000]表示-128：-128的由来如下(也就是说-0就是-128)：**



(-1) + (-127) = [1000 0001]原+ [1111 1111]原= [1111 1111]补+ [1000 0001]补= [1000 0000]补

-1-127的结果应该是-128，在用补码运算的结果中，[1000 0000]补就是-128，但是注意因为实际上是使用以前的-0的补码来表示-128，所以-128并没有原码和反码表示。(对-128的补码表示[1000 0000]补，算出来的原码是[0000 0000]原，这是不正确的)

使用补码，不仅仅修复了0的符号以及存在两个编码的问题，而且还能够多表示一个最低数。这就是为什么8位二进制，使用原码或反码表示的范围为[-127, +127]，而使用补码表示的范围为[-128, 127]。

因为机器使用补码，所以对于编程中常用到的有符号的32位int类型，可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位，而使用补码表示时又可以多保存一个最小值。





#### 总结

**为什么byte的范围是[-128,127]？**

换算成原码则范围是 1 111,1111 -> 0 111,1111 其中 1 111,1111为-127, 0 111,1111为127

但是原码 0有两种表示方式 +0和-0

正0为 0000 0000

负0为 1000 0000

所以这里有个规则，把1000 0000定义为-128了，所以byte的访问是-128



原码: 符号位加真值

反码: 正数的反码不变，负数的反码符号不变，其他取反 

补码: 正数的补码不变，负数的补码为反码加1 ，

移码: 正数的移码不变，负数的移码为绝对值二进制的每位取反再加1

即在负数的情况下:

反码 = 补码-1

补码 = 反码+1 也可以是原码的绝对值取反+1

移码 = 补码符号位取反

#### 移码

移码为补码符号位取反
